# Yield Optimization Agent - Implementation Plan

## ⚠️ CRITICAL SAFETY REQUIREMENTS

**MONEY IS INVOLVED - Safety is Paramount**

### Mandatory Requirements:

1. **Safety Warning in ALL Transaction Responses**: Every transaction object MUST include:

   ```
   ⚠️ CRITICAL: This transaction object was generated by an AI agent.
   Please verify all details (token address, protocol address, amount, chain)
   before executing. Double-check on block explorer and protocol website.
   This is not financial advice.
   ```

2. **Address + Chain Requirement**: When user provides token address, chain MUST be required. Never proceed without chain validation.

3. **Comprehensive Input Validation**: Validate ALL inputs before making API calls:

   - Address format validation
   - Chain support validation
   - Amount validation
   - Balance verification
   - Protocol existence verification

4. **Pre-Transaction Safety Checks**: Run comprehensive checks before generating any transaction:

   - Token exists on chain
   - Protocol exists for token on chain
   - User has sufficient balance
   - Protocol safety evaluation
   - All parameters are valid

5. **Error Handling**: All errors must be:

   - Clear and actionable
   - Include suggestions when possible
   - Never proceed with invalid data

6. **Quick Mode Support**: Support one-command input (address, chain, protocol, amount) but maintain all safety checks and warnings.

## Overview

This agent helps users find the best yield opportunities for their tokens by:

1. Fetching comprehensive token information (name, symbol, marketcap, address, chain)
2. Discovering available staking protocols/vaults using Enso SDK
3. Evaluating protocol safety and yield metrics
4. Generating transaction objects for user confirmation

**All operations prioritize safety over convenience.**

## Architecture

### Agent Structure

Following the pattern from `hyperliquid-agent` and `coingecko-agent`:

- **Framework**: LangChain + LangGraph with React Agent pattern
- **LLM**: OpenAI GPT-4o-mini (configurable)
- **Tools**: Custom tools for token info, protocol discovery, and transaction generation
- **Output Schema**: Structured Zod schema for consistent responses

### Directory Structure

```
yield-agent/
├── src/
│   ├── agent/
│   │   ├── index.ts              # Main agent orchestration
│   │   ├── tools.ts               # LangChain tools definitions
│   │   ├── api.ts                 # External API integrations
│   │   ├── enso-service.ts        # Enso SDK wrapper
│   │   ├── safety-service.ts     # Protocol safety evaluation
│   │   ├── system-prompt.ts       # Agent system prompt
│   │   ├── output-structure.ts   # Response schema
│   │   └── types.ts              # TypeScript types
│   ├── common/
│   │   ├── index.ts
│   │   ├── logger.ts
│   │   ├── types.ts
│   │   └── utils.ts
│   └── index.ts                  # Public API exports
├── package.json
├── tsconfig.json
└── README.md
```

## Implementation Phases

### Phase 1: Token Information Retrieval

#### 1.1 Token Lookup Service

**File**: `src/agent/api.ts`

**Functionality**:

- Accept token name or address as input
- **CRITICAL**: If address is provided, chain MUST be provided (validation required)
- Resolve token across multiple chains
- Fetch comprehensive token metadata

**Input Validation**:

```typescript
interface TokenInput {
  token: string; // Token name, symbol, or address
  chainId?: number; // REQUIRED if token is an address
  chainName?: string; // Alternative to chainId (e.g., "ethereum", "arbitrum")
}

// Validation function
function validateTokenInput(input: TokenInput): ValidationResult {
  const isAddress = isAddress(input.token); // Using viem isAddress

  if (isAddress && !input.chainId && !input.chainName) {
    return {
      valid: false,
      error:
        "Chain must be provided when token address is used. Please specify chainId or chainName.",
      requiredFields: ["chainId or chainName"],
    };
  }

  if (isAddress && input.chainId) {
    // Validate chainId is supported
    if (!SUPPORTED_CHAINS.includes(input.chainId)) {
      return {
        valid: false,
        error: `Chain ID ${
          input.chainId
        } is not supported. Supported chains: ${SUPPORTED_CHAINS.join(", ")}`,
        supportedChains: SUPPORTED_CHAINS,
      };
    }
  }

  return { valid: true };
}
```

**APIs to Use**:

- **Primary**: CoinGecko API (via `@coingecko/coingecko-typescript` or MCP)
  - Search by name/symbol: `coins.search()`
  - Get token by contract: `coins.contract.get()` (requires chain)
  - Get market data: `coins.markets.get()`
- **Fallback**: Enso SDK `getTokenData()` for on-chain metadata

**Data to Collect**:

```typescript
interface TokenInfo {
  name: string;
  symbol: string;
  address: string; // Contract address
  chain: SupportedChain; // Chain where token exists
  chainId: number; // Chain ID
  marketCap?: number; // USD market cap
  price?: number; // Current USD price
  decimals: number;
  logoURI?: string;
  description?: string; // Token description/news
  priceChange24h?: number; // 24h price change %
  volume24h?: number; // 24h trading volume
  coingeckoId?: string; // CoinGecko ID for further lookups
  allChains?: Array<{
    // All chains where token exists
    chainId: number;
    chainName: string;
    address: string;
  }>;
  verified?: boolean; // Whether token is verified on CoinGecko
  warnings?: string[]; // Any warnings about the token
}
```

**Edge Cases to Handle**:

1. **Invalid address format**: Validate Ethereum address format (checksum, length)
2. **Address not found**: Handle cases where address doesn't exist on specified chain
3. **Multiple tokens with same name**: Return all matches, ask user to select
4. **Token not on supported chain**: Inform user and suggest alternative chains
5. **Token not verified**: Warn user about unverified tokens
6. **Network errors**: Retry logic with exponential backoff
7. **Rate limiting**: Implement rate limit handling and caching
8. **Invalid chain name**: Map common chain names to chain IDs, validate

**Tools**:

- `get_token_info`: Fetch token information by name or address (with chain validation)
- `search_token`: Search for tokens by name/symbol (fuzzy search)
- `validate_address`: Validate Ethereum address format and checksum
- `resolve_chain`: Resolve chain name to chain ID

#### 1.2 Token Confirmation Flow

- Present token information to user
- **Always include safety warning**: "⚠️ Please verify token details before proceeding"
- Allow user to confirm or select correct token if multiple matches
- Store confirmed token for next phase

---

### Phase 2: Protocol Discovery via Enso SDK

#### 2.1 Enso SDK Integration

**File**: `src/agent/enso-service.ts`

**Dependencies**:

```json
{
  "@ensofinance/sdk": "^1.0.18"
}
```

**Key Methods**:

1. **`getTokenData()`** - Find vaults/protocols that accept a token

   ```typescript
   ensoClient.getTokenData({
     underlyingTokensExact: [tokenAddress], // Array of token addresses
     chainId: chainId, // Specific chain
     includeMetadata: true,
     type: "defi", // Only DeFi vaults
   });
   ```

2. **`getPriceData()`** - Get token price information

   ```typescript
   ensoClient.getPriceData({ address: tokenAddress, chainId });
   ```

3. **`getApprovalData()`** - Get token approval transaction data
   ```typescript
   ensoClient.getApprovalData({
     fromAddress: userAddress,
     tokenAddress: tokenAddress,
     chainId: chainId,
     amount: amount, // Amount to approve (in wei or as string)
   });
   ```
   Returns approval transaction object that must be executed before deposit transaction.

**Supported Chains**:

```typescript
enum SupportedChainId {
  ETHEREUM = 1,
  ARBITRUM = 42161,
  OPTIMISM = 10,
  POLYGON = 137,
  BASE = 8453,
  AVALANCHE = 43114,
  BNB_CHAIN = 56,
}
```

**Functionality**:

- Query Enso SDK for each supported chain
- Filter results to only include vaults/protocols (type: 'defi')
- Collect APY, TVL, protocol name, and other metrics

**Tools**:

- `discover_protocols`: Find all available staking protocols for a token
- `get_protocol_details`: Get detailed information about a specific protocol
- `check_approval_status`: Check if token approval is needed and current allowance
- `get_approval_transaction`: Generate approval transaction if needed

#### 2.2 Protocol Data Structure

```typescript
interface ProtocolVault {
  address: string; // Vault contract address
  name: string; // Vault name
  symbol: string; // Vault token symbol
  protocol: string; // Protocol name (e.g., "aave", "compound")
  chainId: number; // Chain ID
  chainName: string; // Human-readable chain name
  apy: number; // Annual Percentage Yield
  tvl: number; // Total Value Locked (USD)
  underlyingTokens: Array<{
    // Underlying tokens
    address: string;
    symbol: string;
    name: string;
  }>;
  logosUri?: string[]; // Protocol logo URLs
  project?: string; // Project identifier
}
```

---

### Phase 3: Safety Evaluation

#### 3.1 Safety Scoring System

**File**: `src/agent/safety-service.ts`

**Safety Factors**:

1. **TVL (Total Value Locked)**

   - Higher TVL = More established/trusted
   - Thresholds: >$100M (Very Safe), $10M-$100M (Safe), <$10M (Risky)

2. **Protocol Reputation**

   - Well-known protocols: Aave, Compound, Lido, Yearn, etc.
   - Maintain a whitelist of trusted protocols
   - Check protocol age and audit history

3. **Audit Status** (via external APIs)

   - Check CertiK, OpenZeppelin, Trail of Bits audits
   - Use DefiLlama API or similar for protocol security scores

4. **Historical Performance**
   - Check if protocol has been stable over time
   - Look for any security incidents

**Safety Score Calculation**:

```typescript
interface SafetyScore {
  overall: "very_safe" | "safe" | "moderate" | "risky";
  score: number; // 0-100
  factors: {
    tvl: { score: number; level: string };
    protocol: { score: number; level: string; reputation: string };
    audits: { score: number; level: string; auditCount: number };
    history: { score: number; level: string };
  };
  warnings?: string[]; // Any safety warnings
  recommendations?: string[]; // Safety recommendations
}
```

**APIs for Safety Data**:

- **DefiLlama API**: `https://api.llama.fi/protocol/{protocol}`
  - TVL data, protocol info, audits
- **CertiK API**: Protocol security scores (if available)
- **CoinGecko**: Additional protocol metadata

**Tools**:

- `evaluate_protocol_safety`: Calculate safety score for a protocol
- `compare_protocols`: Compare multiple protocols by safety and yield

---

### Phase 4: Transaction Object Generation

#### 4.1 Token Approval Check & Generation

**File**: `src/agent/enso-service.ts`

**CRITICAL**: Before generating deposit transaction, check if approval is needed.

**Approval Check Flow**:

```typescript
async function checkApprovalNeeded(
  userAddress: string,
  tokenAddress: string,
  protocolAddress: string,
  chainId: number,
  amount: bigint
): Promise<ApprovalCheckResult> {
  try {
    // Check current allowance
    const currentAllowance = await getTokenAllowance(
      userAddress,
      tokenAddress,
      protocolAddress,
      chainId
    );

    if (currentAllowance >= amount) {
      return {
        approvalNeeded: false,
        currentAllowance,
        requiredAmount: amount,
        message: "Sufficient allowance already exists",
      };
    }

    // Approval needed - generate approval transaction
    const approvalData = await ensoClient.getApprovalData({
      fromAddress: userAddress,
      tokenAddress: tokenAddress,
      chainId: chainId,
      amount: amount.toString(), // Amount to approve
    });

    return {
      approvalNeeded: true,
      currentAllowance,
      requiredAmount: amount,
      approvalTransaction: {
        to: approvalData.to,
        data: approvalData.data,
        value: approvalData.value || "0",
        gasLimit: approvalData.gasLimit,
        gasPrice: approvalData.gasPrice,
        chainId: chainId,
        tokenAddress: tokenAddress,
        spender: protocolAddress,
        amount: amount.toString(),
        type: "approve" as const,
      },
      message: "Approval transaction required before deposit",
    };
  } catch (error) {
    return {
      approvalNeeded: false,
      error: `Failed to check approval: ${error.message}`,
      message: "Could not verify approval status",
    };
  }
}
```

**Approval Transaction Structure**:

```typescript
interface ApprovalTransaction {
  to: string; // Token contract address
  data: string; // Encoded approve() call data
  value: string; // Always "0" for ERC20 approvals
  gasLimit?: string;
  gasPrice?: string;
  chainId: number;
  tokenAddress: string; // Token being approved
  spender: string; // Protocol/vault address to approve
  amount: string; // Amount to approve (in wei)
  type: "approve";
  safetyWarning: string; // Mandatory safety warning
}
```

#### 4.2 Enso Bundle Creation

**File**: `src/agent/enso-service.ts`

**Using Enso SDK `getBundleData()`**:

```typescript
const bundleActions: BundleAction[] = [
  {
    protocol: protocolName, // e.g., "aave-v3"
    action: BundleActionType.Deposit,
    args: {
      tokenIn: tokenAddress, // User's token address
      tokenOut: vaultAddress, // Vault/LP token address
      amountIn: amount, // Amount to deposit (in wei)
      primaryAddress: vaultAddress, // Primary vault address
    },
  },
];

const bundleParams: BundleParams = {
  chainId: selectedChainId,
  fromAddress: userAddress, // User's wallet address
  routingStrategy: "router", // Use router for best execution
  receiver: userAddress, // Receiver address
};

const txData = await ensoClient.getBundleData(bundleParams, bundleActions);
```

**Transaction Object Structure**:

```typescript
interface DepositTransaction {
  to: string; // Contract address to interact with
  data: string; // Encoded transaction data
  value: string; // ETH value (if native token)
  gasLimit?: string; // Estimated gas limit
  gasPrice?: string; // Gas price
  chainId: number; // Chain ID
  protocol: string; // Protocol name
  action: "deposit" | "stake"; // Action type
  tokenIn: {
    address: string;
    symbol: string;
    amount: string; // Human-readable amount
  };
  tokenOut: {
    address: string;
    symbol: string;
  };
  estimatedGas?: string; // Estimated gas cost in USD
  slippage?: number; // Slippage tolerance
  type: "deposit";
  safetyWarning: string; // Mandatory safety warning
}

interface TransactionBundle {
  approvalTransaction?: ApprovalTransaction; // Required if approval needed
  depositTransaction: DepositTransaction; // Always present
  executionOrder: ("approve" | "deposit")[]; // Order of execution
  totalGasEstimate?: string; // Combined gas estimate
}
```

**Complete Transaction Generation Flow**:

```typescript
async function generateTransactionBundle(
  userAddress: string,
  tokenAddress: string,
  protocolAddress: string,
  protocolName: string,
  chainId: number,
  amount: bigint,
  tokenSymbol: string
): Promise<TransactionBundle> {
  // Step 1: Check if approval is needed
  const approvalCheck = await checkApprovalNeeded(
    userAddress,
    tokenAddress,
    protocolAddress,
    chainId,
    amount
  );

  // Step 2: Generate deposit transaction
  const bundleActions: BundleAction[] = [
    {
      protocol: protocolName,
      action: BundleActionType.Deposit,
      args: {
        tokenIn: tokenAddress,
        tokenOut: protocolAddress,
        amountIn: amount.toString(),
        primaryAddress: protocolAddress,
      },
    },
  ];

  const bundleParams: BundleParams = {
    chainId: chainId,
    fromAddress: userAddress,
    routingStrategy: "router",
    receiver: userAddress,
  };

  const depositTxData = await ensoClient.getBundleData(
    bundleParams,
    bundleActions
  );

  const depositTransaction: DepositTransaction = {
    to: depositTxData.tx.to,
    data: depositTxData.tx.data,
    value: depositTxData.tx.value || "0",
    gasLimit: depositTxData.tx.gasLimit,
    gasPrice: depositTxData.tx.gasPrice,
    chainId: chainId,
    protocol: protocolName,
    action: "deposit",
    tokenIn: {
      address: tokenAddress,
      symbol: tokenSymbol,
      amount: formatUnits(amount, decimals),
    },
    tokenOut: {
      address: protocolAddress,
      symbol: protocolName,
    },
    type: "deposit",
    safetyWarning:
      "⚠️ CRITICAL: This transaction object was generated by an AI agent. Please verify all details before executing. This is not financial advice.",
  };

  // Step 3: Build transaction bundle
  const executionOrder: ("approve" | "deposit")[] = [];
  if (approvalCheck.approvalNeeded && approvalCheck.approvalTransaction) {
    executionOrder.push("approve", "deposit");
    return {
      approvalTransaction: approvalCheck.approvalTransaction,
      depositTransaction,
      executionOrder,
      totalGasEstimate: calculateTotalGas(
        approvalCheck.approvalTransaction.gasLimit,
        depositTransaction.gasLimit
      ),
    };
  }

  executionOrder.push("deposit");
  return {
    depositTransaction,
    executionOrder,
  };
}
```

**Tools**:

- `check_approval_status`: Check if token approval is needed
- `get_approval_transaction`: Generate approval transaction if needed
- `create_deposit_transaction`: Generate transaction object for depositing into a vault
- `create_transaction_bundle`: Generate complete bundle (approval + deposit if needed)
- `estimate_gas`: Estimate gas costs for transactions

---

### Phase 5: Agent Orchestration

#### 5.1 Agent Flow Modes

**Mode 1: Interactive Mode (Default)**
**File**: `src/agent/index.ts`

**Conversation Flow**:

1. **Token Input**: User provides token name or address
   - **Validation**: If address, require chain
   - **Error Handling**: Return clear error if validation fails
2. **Token Info Retrieval**: Agent fetches and displays token information
   - **Safety Check**: Warn if token is unverified or suspicious
3. **User Confirmation**: Agent asks user to confirm token details
   - **Multiple Matches**: Present all matches, require selection
4. **Protocol Discovery**: Agent discovers available protocols across all chains
   - **Error Handling**: Handle no protocols found gracefully
5. **Safety Evaluation**: Agent evaluates and ranks protocols by safety + yield
6. **Protocol Presentation**: Agent presents top protocols with safety scores
   - **Safety Warnings**: Highlight risky protocols
7. **User Selection**: User selects chain and protocol
   - **Validation**: Verify protocol exists on selected chain
8. **Amount Input**: User provides deposit amount (optional, defaults to max)
   - **Balance Check**: Verify user has sufficient balance
9. **Approval Check**: Check if token approval is needed
   - **If approval needed**: Generate approval transaction first
   - **If already approved**: Skip approval step
10. **Transaction Generation**: Agent creates transaction bundle
    - **If approval needed**: Generate both approval and deposit transactions
    - **If not needed**: Generate only deposit transaction
    - **Validation**: Double-check all parameters before generation
11. **Final Confirmation**: Agent presents transaction details for user approval
    - **Show execution order**: "First execute approval, then deposit" (if approval needed)
    - **CRITICAL WARNING**: Always include transaction verification warning for both transactions

**Mode 2: Quick Mode (One-Command)**
**File**: `src/agent/index.ts`

**Input Format**:

```
User provides: token address, chain, protocol, amount (all in one command)
Example: "Deposit 100 USDC on Arbitrum to Aave v3"
Example: "0x... on ethereum to compound, amount 50"
```

**Quick Mode Flow**:

1. **Parse Input**: Extract token, chain, protocol, amount from single command
2. **Validate All Inputs**:
   - Token address format
   - Chain is supported
   - Protocol exists on chain
   - Amount is valid number
3. **Fetch Token Info**: Quick lookup (skip confirmation)
4. **Verify Protocol**: Check protocol exists for token on specified chain
5. **Safety Check**: Quick safety evaluation (still important!)
6. **Approval Check**: Check if approval is needed
7. **Generate Transaction Bundle**: Create approval + deposit transactions if needed
8. **Return Result**: Return token info + protocol info + transaction bundle
   - **Include all warnings**: Safety warnings + transaction verification warning
   - **Show execution order**: Clear instructions on which transaction to execute first

**Quick Mode Validation**:

```typescript
interface QuickModeInput {
  token: string; // Address or name
  chain: string | number; // Chain name or ID
  protocol: string; // Protocol name/identifier
  amount?: string; // Optional amount
}

function parseQuickModeInput(userInput: string): QuickModeInput | Error {
  // Parse using LLM or regex patterns
  // Validate all required fields present
  // Return structured input or error
}
```

#### 5.2 Input Parsing & Validation

**File**: `src/agent/validation.ts`

**Comprehensive Validation**:

```typescript
interface ValidationResult {
  valid: boolean;
  errors?: string[];
  warnings?: string[];
  data?: ParsedInput;
}

function validateInput(input: string): ValidationResult {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Check if it's quick mode (has protocol specified)
  const isQuickMode = detectQuickMode(input);

  if (isQuickMode) {
    const parsed = parseQuickModeInput(input);

    // Validate token
    if (isAddress(parsed.token)) {
      if (!parsed.chain) {
        errors.push("Chain is required when using token address");
      }
      if (!isValidAddress(parsed.token)) {
        errors.push("Invalid token address format");
      }
    }

    // Validate chain
    if (parsed.chain) {
      const chainId = resolveChainId(parsed.chain);
      if (!chainId || !SUPPORTED_CHAINS.includes(chainId)) {
        errors.push(`Unsupported chain: ${parsed.chain}`);
      }
    }

    // Validate protocol
    if (!parsed.protocol) {
      errors.push("Protocol must be specified in quick mode");
    }

    // Validate amount if provided
    if (parsed.amount) {
      const amountNum = parseFloat(parsed.amount);
      if (isNaN(amountNum) || amountNum <= 0) {
        errors.push("Invalid amount. Must be a positive number");
      }
    }

    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : undefined,
      warnings: warnings.length > 0 ? warnings : undefined,
      data: errors.length === 0 ? parsed : undefined,
    };
  }

  // Regular mode validation
  // ... similar validation for regular mode
}
```

#### 5.3 System Prompt

**File**: `src/agent/system-prompt.ts`

```
You are a yield optimization agent that helps users find the best and safest staking opportunities for their tokens.

CRITICAL SAFETY RULES:
1. MONEY IS INVOLVED - Always prioritize safety over yield
2. ALL transaction objects MUST include this warning: "⚠️ CRITICAL: This transaction object was generated by an AI agent. Please verify all details (token address, protocol address, amount, chain) before executing. Double-check on block explorer and protocol website. This is not financial advice."
3. If user provides a token address, you MUST require chain information - never proceed without it
4. Always validate addresses, chain IDs, and amounts before generating transactions
5. When in doubt, ask for clarification rather than making assumptions

INPUT VALIDATION:
- If user provides token address without chain: "Error: Chain must be provided when using token address. Please specify the chain (e.g., ethereum, arbitrum, base)."
- Validate all addresses are valid Ethereum addresses (checksum, length)
- Validate chain IDs are in supported list
- Validate amounts are positive numbers

QUICK MODE DETECTION:
If user provides token address + chain + protocol (+ optional amount) in one command, use quick mode:
- Parse all inputs
- Validate everything upfront
- Skip confirmation steps
- Generate transaction object directly
- Still include all safety warnings and protocol safety scores

Your workflow (Interactive Mode):
1. When a user provides a token name or address:
   - If address: Require chain, validate address format
   - Fetch comprehensive token information including:
     - Token name, symbol, address, and chain
     - Market cap, price, and trading volume
     - Verification status (warn if unverified)
     - Any important news or updates about the token
     - All chains where the token is available

2. Present this information clearly with safety warnings and ask the user to confirm the correct token.
   - Include: "⚠️ Please verify token details before proceeding"

3. Once confirmed, discover all available staking protocols/vaults for this token across supported chains:
   - Ethereum (1), Arbitrum (42161), Optimism (10), Polygon (137), Base (8453), Avalanche (43114), BNB Chain (56)

4. For each protocol, evaluate safety based on:
   - Total Value Locked (TVL)
   - Protocol reputation and audit status
   - Historical performance
   - Any security incidents

5. Present protocols ranked by a combination of yield (APY) and safety, clearly indicating:
   - Protocol name and chain
   - APY percentage
   - Safety score and level (very_safe, safe, moderate, risky)
   - TVL
   - Any safety warnings
   - ⚠️ Highlight risky protocols prominently

6. Once the user selects a chain and protocol:
   - Validate protocol exists on selected chain
   - Ask for amount (or use max balance)
   - Verify user has sufficient balance
   - Check if token approval is needed
   - Generate transaction bundle (approval + deposit if needed, or just deposit)

7. ALWAYS include this warning with ALL transaction objects (approval and deposit):
   "⚠️ CRITICAL: This transaction object was generated by an AI agent. Please verify all details (token address, protocol address, amount, chain) before executing. Double-check on block explorer and protocol website. This is not financial advice."

EDGE CASES TO HANDLE:
- Token not found: "Token not found. Please check spelling or provide contract address with chain."
- No protocols found: "No staking protocols found for this token on supported chains."
- Invalid address: "Invalid address format. Please provide a valid Ethereum address."
- Chain not supported: "Chain not supported. Supported chains: Ethereum, Arbitrum, Optimism, Polygon, Base, Avalanche, BNB Chain"
- Protocol not found on chain: "Protocol not available on selected chain. Available protocols: [list]"
- Insufficient balance: "Insufficient balance. Your balance: X, Required: Y"
- Amount exceeds balance: "Amount exceeds available balance"
- Network errors: "Network error. Please try again."
- Rate limiting: "API rate limit reached. Please wait a moment."

Always prioritize user safety and provide clear warnings about risks. Include "This is not financial advice" in ALL responses.
```

#### 5.4 Output Schema

**File**: `src/agent/output-structure.ts`

```typescript
export const ResponseSchema = z.object({
  answer: z
    .string()
    .describe(
      "The main response to the user. MUST include safety warnings when transaction is present."
    ),
  step: z
    .enum([
      "token_lookup",
      "token_confirmation",
      "protocol_discovery",
      "protocol_selection",
      "amount_input",
      "transaction_ready",
      "quick_mode_complete",
      "error",
    ])
    .describe("Current step in the workflow"),

  mode: z
    .enum(["interactive", "quick"])
    .default("interactive")
    .describe("Agent mode"),

  tokenInfo: z
    .object({
      name: z.string(),
      symbol: z.string(),
      address: z.string(),
      chain: z.string(),
      chainId: z.number(),
      marketCap: z.number().optional(),
      price: z.number().optional(),
      verified: z.boolean().optional(),
      warnings: z.array(z.string()).optional(),
    })
    .nullable()
    .optional(),

  protocols: z
    .array(
      z.object({
        address: z.string(),
        name: z.string(),
        protocol: z.string(),
        chainId: z.number(),
        chainName: z.string(),
        apy: z.number(),
        tvl: z.number(),
        safetyScore: z.object({
          overall: z.enum(["very_safe", "safe", "moderate", "risky"]),
          score: z.number(),
          warnings: z.array(z.string()).optional(),
        }),
      })
    )
    .nullable()
    .optional(),

  approvalTransaction: z
    .object({
      to: z.string().describe("Token contract address (for approval)"),
      data: z.string().describe("Encoded approve() transaction data"),
      value: z.string().describe("ETH value (always 0 for ERC20 approvals)"),
      gasLimit: z.string().optional().describe("Estimated gas limit"),
      gasPrice: z.string().optional().describe("Gas price"),
      chainId: z.number().describe("Chain ID"),
      tokenAddress: z.string().describe("Token address being approved"),
      spender: z.string().describe("Protocol/vault address to approve"),
      amount: z.string().describe("Amount to approve (in wei)"),
      type: z.literal("approve").describe("Transaction type"),
      safetyWarning: z
        .string()
        .describe("Mandatory safety warning about verifying transaction"),
    })
    .nullable()
    .optional()
    .describe("Approval transaction if token approval is needed"),

  transaction: z
    .object({
      to: z.string().describe("Contract address to interact with"),
      data: z.string().describe("Encoded transaction data"),
      value: z.string().describe("ETH value (if native token)"),
      gasLimit: z.string().optional().describe("Estimated gas limit"),
      gasPrice: z.string().optional().describe("Gas price"),
      chainId: z.number().describe("Chain ID"),
      protocol: z.string().describe("Protocol name"),
      action: z.enum(["deposit", "stake"]).describe("Action type"),
      tokenIn: z.object({
        address: z.string(),
        symbol: z.string(),
        amount: z.string().describe("Human-readable amount"),
        amountWei: z.string().describe("Amount in wei"),
      }),
      tokenOut: z.object({
        address: z.string(),
        symbol: z.string(),
      }),
      estimatedGas: z.string().optional().describe("Estimated gas cost in USD"),
      slippage: z.number().optional().describe("Slippage tolerance"),
      type: z.literal("deposit").describe("Transaction type"),
      // CRITICAL: Safety warning must be included
      safetyWarning: z
        .string()
        .describe("Mandatory safety warning about verifying transaction"),
    })
    .nullable()
    .optional()
    .describe("Deposit/stake transaction"),

  executionOrder: z
    .array(z.enum(["approve", "deposit"]))
    .optional()
    .describe("Order in which transactions should be executed"),

  totalGasEstimate: z
    .string()
    .optional()
    .describe("Total estimated gas for all transactions"),

  validationErrors: z
    .array(z.string())
    .optional()
    .describe("Input validation errors"),
  warnings: z.array(z.string()).optional().describe("General warnings"),

  confidence: z.enum(["high", "medium", "low"]).describe("Confidence level"),
});

// Helper function to ensure safety warning is always included
export function ensureSafetyWarning(response: AgentResponse): AgentResponse {
  const safetyWarning =
    "⚠️ CRITICAL: This transaction object was generated by an AI agent. Please verify all details (token address, protocol address, amount, chain) before executing. Double-check on block explorer and protocol website. This is not financial advice.";

  // Ensure approval transaction has warning
  if (
    response.approvalTransaction &&
    !response.approvalTransaction.safetyWarning
  ) {
    response.approvalTransaction.safetyWarning = safetyWarning;
  }

  // Ensure deposit transaction has warning
  if (response.transaction && !response.transaction.safetyWarning) {
    response.transaction.safetyWarning = safetyWarning;
  }

  // Also ensure answer includes warning
  if (
    (response.approvalTransaction || response.transaction) &&
    !response.answer.includes("CRITICAL")
  ) {
    const executionNote = response.approvalTransaction
      ? "\n\n⚠️ IMPORTANT: You must execute the approval transaction FIRST, then wait for confirmation before executing the deposit transaction."
      : "";
    response.answer +=
      "\n\n⚠️ CRITICAL: This transaction object was generated by an AI agent. Please verify all details before executing. This is not financial advice." +
      executionNote;
  }

  return response;
}
```

---

## Dependencies

### Core Dependencies

```json
{
  "@langchain/core": "^0.3.78",
  "@langchain/langgraph": "^0.4.9",
  "@langchain/openai": "^0.6.16",
  "@ensofinance/sdk": "^1.0.18",
  "@coingecko/coingecko-typescript": "^1.0.x",
  "zod": "^3.24.1",
  "viem": "^2.x"
}
```

### Environment Variables

```env
OPENAI_API_KEY=your_openai_key
ENSO_API_KEY=your_enso_api_key
COINGECKO_API_KEY=your_coingecko_key  # Optional but recommended
```

---

## API Integration Details

### CoinGecko API

- **Base URL**: `https://api.coingecko.com/api/v3`
- **Endpoints**:
  - Search: `/search?query={query}`
  - Token by contract: `/coins/{chain}/contract/{address}`
  - Market data: `/coins/markets?vs_currency=usd&ids={ids}`

### Enso SDK

- **Initialization**: Requires API key
- **Key Methods**:
  - `getTokenData()` - Find vaults for tokens
  - `getBundleData()` - Generate transaction bundles
  - `getApprovalData()` - Generate token approval transactions
  - `getPriceData()` - Get token prices

### DefiLlama API (for safety)

- **Base URL**: `https://api.llama.fi`
- **Endpoints**:
  - Protocol info: `/protocol/{protocol}`
  - TVL data: `/tvl/{protocol}`

---

## Error Handling & Edge Cases

### Input Validation Errors

#### Token Address Validation

```typescript
function validateTokenAddress(
  address: string,
  chainId?: number
): ValidationResult {
  // Check format
  if (!isAddress(address)) {
    return { valid: false, error: "Invalid Ethereum address format" };
  }

  // Check checksum
  if (!isValidChecksumAddress(address)) {
    return {
      valid: false,
      error: "Invalid address checksum. Please use checksummed address.",
      suggestion: getChecksummedAddress(address),
    };
  }

  // If address provided, chain must be provided
  if (!chainId) {
    return {
      valid: false,
      error: "Chain must be provided when using token address",
      requiredFields: ["chainId or chainName"],
    };
  }

  return { valid: true };
}
```

#### Chain Validation

```typescript
function validateChain(chain: string | number): ValidationResult {
  const chainId =
    typeof chain === "string"
      ? resolveChainNameToId(chain.toLowerCase())
      : chain;

  if (!SUPPORTED_CHAINS.includes(chainId)) {
    return {
      valid: false,
      error: `Unsupported chain. Chain ID: ${chainId}`,
      supportedChains: SUPPORTED_CHAINS.map((id) => ({
        id,
        name: getChainName(id),
      })),
    };
  }

  return { valid: true, chainId };
}
```

#### Amount Validation

```typescript
function validateAmount(
  amount: string,
  balance: bigint,
  decimals: number
): ValidationResult {
  const amountNum = parseFloat(amount);

  if (isNaN(amountNum) || amountNum <= 0) {
    return { valid: false, error: "Amount must be a positive number" };
  }

  const amountWei = parseUnits(amount, decimals);

  if (amountWei > balance) {
    return {
      valid: false,
      error: `Insufficient balance. Available: ${formatUnits(
        balance,
        decimals
      )}, Requested: ${amount}`,
      available: formatUnits(balance, decimals),
      requested: amount,
    };
  }

  return { valid: true, amountWei };
}
```

### Token Lookup Errors

#### Edge Cases:

1. **Token not found**

   - Error: "Token not found. Please check spelling or provide contract address with chain."
   - Suggestion: Provide similar token names if available

2. **Multiple token matches**

   - Return all matches with details
   - Ask user to select: "Multiple tokens found. Please select: [list with details]"

3. **Token not on supported chains**

   - Error: "Token not available on supported chains."
   - Show available chains: "Token is available on: [chains]"

4. **Invalid address format**

   - Error: "Invalid address format. Must be 42 characters starting with 0x."
   - Provide format example

5. **Address doesn't exist on chain**

   - Error: "Address not found on specified chain. Please verify chain and address."

6. **Unverified token**

   - Warning: "⚠️ This token is not verified on CoinGecko. Please verify manually."

7. **Network/API errors**
   - Retry with exponential backoff (3 attempts)
   - Error: "Network error. Please try again. [Error details]"

### Protocol Discovery Errors

#### Edge Cases:

1. **No protocols found**

   - Error: "No staking protocols found for this token on supported chains."
   - Suggestion: "Try searching on different chains or check if token supports staking."

2. **Protocol not found on specified chain**

   - Error: "Protocol '{protocol}' not available on {chain}."
   - Show available protocols: "Available protocols on {chain}: [list]"

3. **API rate limiting**

   - Implement request queuing
   - Error: "API rate limit reached. Please wait a moment and try again."
   - Retry after delay

4. **Network timeout**

   - Retry with exponential backoff
   - Error: "Request timeout. Please check your connection and try again."

5. **Invalid protocol identifier**
   - Error: "Protocol '{protocol}' not recognized."
   - Show available protocols: "Available protocols: [list]"

### Transaction Generation Errors

#### Edge Cases:

1. **Insufficient balance**

   - Check balance before generating transaction
   - Error: "Insufficient balance. Available: {balance}, Required: {amount}"

2. **Unsupported protocol/chain combination**

   - Validate before generation
   - Error: "Protocol '{protocol}' is not available on {chain}."

3. **Invalid amount**

   - Validate amount format and range
   - Error: "Invalid amount. Must be positive number."

4. **Gas estimation failure**

   - Error: "Failed to estimate gas. Transaction may fail. Please verify parameters."

5. **Token approval required but failed**

   - Check if approval is needed
   - Error: "Token approval required but failed. Please approve token first."

6. **Approval transaction generation failed**

   - Error: "Failed to generate approval transaction. Please check token and protocol addresses."

7. **Approval already exists**

   - Info: "Token already approved. Proceeding with deposit transaction only."

8. **Slippage too high**

   - Warning: "⚠️ High slippage detected. Consider adjusting amount or waiting."

9. **Transaction would fail**
   - Simulate transaction if possible
   - Error: "Transaction would likely fail. Please verify: [reasons]"

### Balance Verification

```typescript
async function verifyBalance(
  userAddress: string,
  tokenAddress: string,
  chainId: number,
  requiredAmount: bigint
): Promise<BalanceCheckResult> {
  try {
    // Get user balance
    const balance = await getTokenBalance(userAddress, tokenAddress, chainId);

    if (balance < requiredAmount) {
      return {
        sufficient: false,
        balance,
        required: requiredAmount,
        shortfall: requiredAmount - balance,
        error: `Insufficient balance. Available: ${formatUnits(
          balance
        )}, Required: ${formatUnits(requiredAmount)}`,
      };
    }

    return { sufficient: true, balance, required: requiredAmount };
  } catch (error) {
    return {
      sufficient: false,
      error: `Failed to check balance: ${error.message}`,
    };
  }
}
```

### Comprehensive Error Response Structure

```typescript
interface ErrorResponse {
  error: true;
  errorType:
    | "validation"
    | "network"
    | "not_found"
    | "insufficient_balance"
    | "transaction_failed";
  message: string;
  details?: {
    field?: string;
    value?: any;
    expected?: any;
    suggestions?: string[];
  };
  recoverable: boolean;
  retryable?: boolean;
}
```

### Safety Checks Before Transaction Generation

```typescript
async function preTransactionChecks(
  tokenAddress: string,
  chainId: number,
  protocol: string,
  amount: bigint,
  userAddress: string
): Promise<SafetyCheckResult> {
  const checks = {
    tokenExists: false,
    protocolExists: false,
    sufficientBalance: false,
    protocolSafe: false,
    allChecksPassed: false,
  };

  const errors: string[] = [];
  const warnings: string[] = [];

  // Check 1: Token exists on chain
  try {
    const tokenInfo = await getTokenInfo(tokenAddress, chainId);
    checks.tokenExists = !!tokenInfo;
    if (!checks.tokenExists) {
      errors.push(`Token not found on chain ${chainId}`);
    }
  } catch (error) {
    errors.push(`Failed to verify token: ${error.message}`);
  }

  // Check 2: Protocol exists for token on chain
  try {
    const protocols = await discoverProtocols(tokenAddress, chainId);
    checks.protocolExists = protocols.some((p) => p.protocol === protocol);
    if (!checks.protocolExists) {
      errors.push(
        `Protocol ${protocol} not available for this token on chain ${chainId}`
      );
    }
  } catch (error) {
    errors.push(`Failed to verify protocol: ${error.message}`);
  }

  // Check 3: User has sufficient balance
  try {
    const balanceCheck = await verifyBalance(
      userAddress,
      tokenAddress,
      chainId,
      amount
    );
    checks.sufficientBalance = balanceCheck.sufficient;
    if (!checks.sufficientBalance) {
      errors.push(balanceCheck.error || "Insufficient balance");
    }
  } catch (error) {
    errors.push(`Failed to check balance: ${error.message}`);
  }

  // Check 4: Protocol safety
  try {
    const safety = await evaluateProtocolSafety(protocol, chainId);
    checks.protocolSafe = safety.overall !== "risky";
    if (!checks.protocolSafe) {
      warnings.push(
        `Protocol has safety score: ${safety.overall}. ${safety.warnings?.join(
          ", "
        )}`
      );
    }
  } catch (error) {
    warnings.push(`Could not evaluate protocol safety: ${error.message}`);
  }

  checks.allChecksPassed = errors.length === 0;

  return {
    checks,
    errors,
    warnings,
    canProceed: checks.allChecksPassed,
  };
}
```

---

## Testing Strategy

### Unit Tests

- Token lookup and resolution
- Protocol discovery logic
- Safety score calculation
- Transaction object generation

### Integration Tests

- End-to-end agent flow
- API integrations (CoinGecko, Enso, DefiLlama)
- Multi-chain protocol discovery

### Example Test Cases

#### Happy Path Tests

1. **Interactive Mode - Token Name**

   - User: "Find staking for USDC"
   - Agent finds token → Shows info → User confirms → Protocols discovered → User selects → Transaction generated
   - ✅ Verify safety warnings included

2. **Quick Mode - Complete Input**
   - User: "Deposit 100 USDC on Arbitrum to Aave v3"
   - Agent parses → Validates → Generates transaction
   - ✅ Verify all validations pass
   - ✅ Verify transaction includes safety warning

#### Edge Case Tests

3. **Address without Chain**

   - User: "0x... (address only)"
   - Agent: Error "Chain must be provided when using token address"
   - ✅ Verify error message is clear

4. **Invalid Address Format**

   - User: "0x123" (too short)
   - Agent: Error "Invalid Ethereum address format"
   - ✅ Verify format validation

5. **Invalid Chain**

   - User: "Token on Fantom"
   - Agent: Error "Unsupported chain. Supported chains: [list]"
   - ✅ Verify chain validation

6. **Token Not Found**

   - User: "Find staking for NONEXISTENTTOKEN"
   - Agent: Error "Token not found. Please check spelling..."
   - ✅ Verify helpful error message

7. **Multiple Token Matches**

   - User: "Find staking for USDT"
   - Agent: Shows multiple USDT variants → Asks user to select
   - ✅ Verify selection prompt

8. **No Protocols Found**

   - User: Valid token but no staking available
   - Agent: Error "No staking protocols found..."
   - ✅ Verify helpful message

9. **Protocol Not on Chain**

   - User: "Deposit to Aave on Polygon" (Aave not on Polygon)
   - Agent: Error "Protocol not available on selected chain"
   - ✅ Verify protocol validation

10. **Insufficient Balance**

    - User: "Deposit 1000 USDC" but only has 100
    - Agent: Error "Insufficient balance. Available: 100, Required: 1000"
    - ✅ Verify balance check

11. **Invalid Amount**

    - User: "Deposit -50 USDC"
    - Agent: Error "Amount must be a positive number"
    - ✅ Verify amount validation

12. **Quick Mode - Missing Protocol**

    - User: "Deposit 100 USDC on Arbitrum" (no protocol)
    - Agent: Error "Protocol must be specified in quick mode"
    - ✅ Verify quick mode validation

13. **Network Error**

    - Simulate API failure
    - Agent: Retries → Error "Network error. Please try again."
    - ✅ Verify retry logic

14. **Rate Limiting**

    - Simulate rate limit
    - Agent: Queues request → Error "API rate limit reached..."
    - ✅ Verify rate limit handling

15. **Unverified Token**

    - User provides unverified token
    - Agent: Warning "⚠️ Token not verified..."
    - ✅ Verify warning displayed

16. **Risky Protocol**

    - Protocol with low TVL
    - Agent: Warning "⚠️ Protocol has safety score: risky"
    - ✅ Verify safety warnings

17. **Transaction Generation Failure**
    - Invalid parameters
    - Agent: Error "Failed to generate transaction: [reason]"
    - ✅ Verify error details

#### Safety Tests

18. **Safety Warning Always Present**

    - Any transaction generation
    - Agent: Must include "⚠️ CRITICAL: This transaction object was generated by an AI agent..."
    - ✅ Verify warning in answer and transaction object

19. **Pre-Transaction Validation**

    - Before generating transaction
    - Agent: Runs all safety checks
    - ✅ Verify all checks pass before generation

20. **Balance Verification**

    - Before transaction generation
    - Agent: Verifies balance
    - ✅ Verify balance check is performed

21. **Approval Transaction Generation**

    - User needs to deposit but approval not set
    - Agent: Generates approval transaction + deposit transaction
    - ✅ Verify approval transaction is generated correctly
    - ✅ Verify execution order is clear

22. **Approval Already Exists**

    - User has sufficient allowance
    - Agent: Skips approval, generates only deposit transaction
    - ✅ Verify approval check is performed
    - ✅ Verify only deposit transaction is returned

23. **Approval Check Failure**

    - Cannot verify approval status
    - Agent: Error "Failed to check approval status"
    - ✅ Verify error handling

24. **Approval Transaction Safety Warning**
    - Approval transaction generated
    - Agent: Includes safety warning in approval transaction
    - ✅ Verify warning is present

---

## Future Enhancements

1. **Amount Input**: Allow users to specify deposit amount
2. **Gas Optimization**: Compare gas costs across chains
3. **Historical APY**: Show APY trends over time
4. **Multi-token Strategies**: Support LP tokens and multi-asset vaults
5. **Portfolio Tracking**: Track user's positions across protocols
6. **Yield Alerts**: Notify users of better opportunities
7. **Risk Analysis**: More sophisticated risk scoring
8. **Slippage Configuration**: Allow users to set slippage tolerance

---

## Implementation Checklist

### Phase 1: Setup & Token Info

- [ ] Initialize project structure
- [ ] Set up dependencies
- [ ] Implement CoinGecko integration
- [ ] Create token lookup tools
- [ ] Implement token confirmation flow

### Phase 2: Protocol Discovery

- [ ] Set up Enso SDK client
- [ ] Implement multi-chain protocol discovery
- [ ] Create protocol data structures
- [ ] Build protocol discovery tools

### Phase 3: Safety Evaluation

- [ ] Research safety scoring methodology
- [ ] Implement TVL-based scoring
- [ ] Integrate DefiLlama API
- [ ] Create protocol reputation database
- [ ] Build safety evaluation tools

### Phase 4: Transaction Generation

- [ ] Implement approval status checking
- [ ] Implement approval transaction generation using Enso SDK
- [ ] Implement Enso bundle creation for deposit transactions
- [ ] Add gas estimation for both approval and deposit
- [ ] Create transaction bundle builder (approval + deposit)
- [ ] Build transaction generation tools
- [ ] Add execution order logic

### Phase 5: Agent Integration

- [ ] Create system prompt
- [ ] Define output schema
- [ ] Implement agent orchestration
- [ ] Add error handling
- [ ] Write tests

### Phase 6: Documentation & Polish

- [ ] Write README
- [ ] Add usage examples
- [ ] Document API endpoints
- [ ] Create example outputs

---

## Notes

1. **API Rate Limits**: Implement caching and rate limit handling for all external APIs
2. **Chain Support**: Start with Ethereum and Arbitrum, then expand to other chains
3. **Safety First**: Always prioritize safety over yield in recommendations
4. **User Confirmation**: Require explicit user confirmation at each critical step (except quick mode)
5. **Gas Costs**: Consider gas costs when comparing yields across chains
6. **Real-time Data**: Use caching for stable data (token info) but fetch fresh data for APY/TVL
7. **CRITICAL - Safety Warnings**: Every transaction object MUST include safety warning. This is non-negotiable.
8. **Address + Chain Requirement**: When address is provided, chain MUST be required. Never proceed without it.
9. **Validation First**: Always validate inputs before making API calls to save time and API costs
10. **Error Messages**: All error messages must be clear, actionable, and include suggestions when possible
11. **Balance Checks**: Always verify balance before generating transactions
12. **Pre-flight Checks**: Run comprehensive safety checks before transaction generation
13. **Quick Mode**: Support one-command input but still include all safety checks and warnings
14. **Money Involved**: Remember real money is at stake - err on the side of caution

---

## Additional Safety Measures

### Transaction Verification Checklist

Before returning any transaction object, verify:

- [ ] Token address is correct and exists on specified chain
- [ ] Protocol address is correct and exists on specified chain
- [ ] Amount is valid and user has sufficient balance
- [ ] Chain ID matches the specified chain
- [ ] Protocol supports the token on the specified chain
- [ ] **Approval status checked** - Verify if approval is needed
- [ ] **If approval needed**: Approval transaction generated with correct spender address
- [ ] **If approval needed**: Execution order clearly indicated (approve first, then deposit)
- [ ] Gas estimation succeeded for all transactions
- [ ] Safety warning is included in ALL transaction responses (approval + deposit)
- [ ] All validation errors are resolved

### Mandatory Warnings in All Responses

1. **Token Information Response**:

   ```
   ⚠️ Please verify token details before proceeding
   ```

2. **Protocol Selection Response**:

   ```
   ⚠️ Please review protocol safety scores and warnings before selecting
   ```

3. **Transaction Object Response** (CRITICAL):

   ```
   ⚠️ CRITICAL: This transaction object was generated by an AI agent.
   Please verify all details (token address, protocol address, amount, chain)
   before executing. Double-check on block explorer and protocol website.
   This is not financial advice.
   ```

4. **If Approval Required**:

   ```
   ⚠️ IMPORTANT: Token approval is required before deposit.
   You must execute the approval transaction FIRST, wait for confirmation,
   then execute the deposit transaction.

   Execution Order:
   1. Execute approval transaction (if provided)
   2. Wait for approval transaction confirmation
   3. Execute deposit transaction
   ```

### Input Validation Summary

| Input Type    | Required Fields          | Validation Rules                        |
| ------------- | ------------------------ | --------------------------------------- |
| Token Name    | token                    | Must be non-empty string                |
| Token Address | token, chainId/chainName | Address format, chain must be supported |
| Quick Mode    | token, chain, protocol   | All fields validated, amount optional   |
| Amount        | amount                   | Positive number, <= balance             |

## Questions Resolved

1. ✅ **Partial amounts**: Support both partial and full balance (user specifies amount)
2. ✅ **Token approvals**:
   - Check approval status before generating deposit transaction
   - Generate approval transaction if needed using `ensoClient.getApprovalData()`
   - Return both approval and deposit transactions with clear execution order
   - Approval transaction MUST be executed first, then deposit
3. ✅ **Caching**: Cache stable data (token info), fetch fresh for APY/TVL
4. ✅ **TVL threshold**: >$100M (Very Safe), $10M-$100M (Safe), <$10M (Risky)
5. ✅ **Wallet integration**: Just return transaction objects, let user execute via their wallet
6. ✅ **Address + Chain**: REQUIRED when address is provided - no exceptions
7. ✅ **Safety warnings**: MANDATORY in all transaction responses (approval + deposit)
8. ✅ **Quick mode**: Supported with full validation and safety checks
9. ✅ **Execution order**: Always provide clear instructions: approve first (if needed), then deposit
